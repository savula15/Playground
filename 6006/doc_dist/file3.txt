
26if (current == NULL) return;// do nothing if the list is empty// Compare current node with next nodewhile(current->next!=NULL) {if (current->data == current->next->data) {struct node* nextNext = current->next->next;free(current->next);current->next = nextNext;}else {current = current->next;// only advance if no deletion}}}11 — MoveNode() SolutionThe MoveNode() code is most similar to the code for Push(). It's short — just changing acouple pointers — but it's complex. Make a drawing.void MoveNode(struct node** destRef, struct node** sourceRef) {struct node* newNode = *sourceRef;// the front source nodeassert(newNode != NULL);*sourceRef = newNode->next;// Advance the source pointernewNode->next = *destRef;// Link the old dest off the new node*destRef = newNode;// Move dest to point to the new node}12 — AlternatingSplit() SolutionThe simplest approach iterates over the source list and use MoveNode() to pull nodes offthe source and alternately put them on 'a' and b'. The only strange part is that the nodeswill be in the reverse order that they occurred in the source list.AlternatingSplit()void AlternatingSplit(struct node* source,struct node** aRef, struct node** bRef) {struct node* a = NULL;// Split the nodes to these 'a' and 'b' listsstruct node* b = NULL;struct node* current = source;while (current != NULL) {MoveNode(&a, &current);// Move a node to 'a'if (current != NULL) {MoveNode(&b, &current);// Move a node to 'b'}}*aRef = a;*bRef = b;}
27AlternatingSplit() Using Dummy NodesHere is an alternative approach which builds the sub-lists in the same order as the sourcelist. The code uses a temporary dummy header nodes for the 'a' and 'b' lists as they arebeing built. Each sublist has a "tail" pointer which points to its current last node — thatway new nodes can be appended to the end of each list easily. The dummy nodes give thetail pointers something to point to initially. The dummy nodes are efficient in this casebecause they are temporary and allocated in the stack. Alternately, the "local references"technique could be used to get rid of the dummy nodes  (see Section 1 for more details).void AlternatingSplit2(struct node* source,struct node** aRef, struct node** bRef) {struct node aDummy;struct node* aTail = &aDummy;// points to the last node in 'a'struct node bDummy;struct node* bTail = &bDummy;// points to the last node in 'b'struct node* current = source;aDummy.next = NULL;bDummy.next = NULL;while (current != NULL) {MoveNode(&(aTail->next), &current);// add at 'a' tailaTail = aTail->next;// advance the 'a' tailif (current != NULL) {MoveNode(&(bTail->next), &current);bTail = bTail->next;}}*aRef = aDummy.next;*bRef = bDummy.next;}13 SuffleMerge() SolutionThere are four separate solutions included. See Section 1 for information on the variousdummy node and reference techniques. SuffleMerge() — Dummy Node Not Using MoveNode()struct node* ShuffleMerge(struct node* a, struct node* b) {struct node dummy;struct node* tail = &dummy;dummy.next = NULL;while (1) {if (a==NULL) {// empty list casestail->next = b;break;}else if (b==NULL) {tail->next = a;break;}else {// common case: move two nodes to tailtail->next = a;tail = a;a = a->next;
28tail->next = b;tail = b;b = b->next;}}return(dummy.next);}SuffleMerge() —  Dummy Node Using MoveNode()Basically the same as above, but use MoveNode().struct node* ShuffleMerge(struct node* a, struct node* b) {struct node dummy;struct node* tail = &dummy;dummy.next = NULL;while (1) {if (a==NULL) {tail->next = b;break;}else if (b==NULL) {tail->next = a;break;}else {MoveNode(&(tail->next), &a);tail = tail->next;MoveNode(&(tail->next), &b);tail = tail->next;}}return(dummy.next);}SuffleMerge() —  Local ReferencesUses a local reference to get rid of the dummy nodes entirely.struct node* ShuffleMerge(struct node* a, struct node* b) {struct node* result = NULL;struct node** lastPtrRef = &result;while (1) {if (a==NULL) {*lastPtrRef = b;break;}else if (b==NULL) {*lastPtrRef = a;break;}else {MoveNode(lastPtrRef, &a);lastPtrRef = &((*lastPtrRef)->next);MoveNode(lastPtrRef, &b);lastPtrRef = &((*lastPtrRef)->next);
29}}return(result);}SuffleMerge() —  RecursiveThe recursive solution is the most compact of all, but is probably not appropriate forproduction code since it uses stack space proportionate to the lengths of the lists.struct node* ShuffleMerge(struct node* a, struct node* b) {struct node* result;struct node* recur;if (a==NULL) return(b);// see if either list is emptyelse if (b==NULL) return(a);else {// it turns out to be convenient to do the recursive call first --// otherwise a->next and b->next need temporary storage.recur = ShuffleMerge(a->next, b->next);result = a;// one node from aa->next = b;// one from bb->next = recur;// then the restreturn(result);}}14 —  SortedMerge() SolutionSortedMerge() Using Dummy NodesThe strategy here uses a temporary dummy node as the start of the result list. The pointertail always points to the last node in the result list, so appending new nodes is easy.The dummy node gives tail something to point to initially when the result list is empty.This dummy node is efficient, since it is only temporary, and it is allocated in the stack.The loop proceeds, removing one node from either 'a' or 'b', and adding it to tail. Whenwe are done, the result is in dummy.next.struct node* SortedMerge(struct node* a, struct node* b) {struct node dummy;// a dummy first node to hang the result onstruct node* tail = &dummy;// Points to the last result node --// so tail->next is the place to add// new nodes to the result.dummy.next = NULL;while (1) {if (a == NULL) {// if either list runs out, use the other listtail->next = b;break;}else if (b == NULL) {tail->next = a;break;}
30if (a->data <= b->data) {MoveNode(&(tail->next), &a);}else {MoveNode(&(tail->next), &b);}tail = tail->next;}return(dummy.next);}SortedMerge() Using Local ReferencesThis solution is structurally very similar to the above, but it avoids using a dummy node.Instead, it maintains a struct node** pointer, lastPtrRef, that always points to the lastpointer of the result list. This solves the same case that the dummy node did — dealingwith the result list when it is empty. If you are trying to build up a list at its tail, either thedummy node or the  struct node** "reference" strategy can be used (see Section 1 fordetails).struct node* SortedMerge2(struct node* a, struct node* b) {struct node* result = NULL;struct node** lastPtrRef = &result;// point to the last result pointerwhile (1) {if (a==NULL) {*lastPtrRef = b;break;}else if (b==NULL) {*lastPtrRef = a;break;}if (a->data <= b->data) {MoveNode(lastPtrRef, &a);}else {MoveNode(lastPtrRef, &b);}lastPtrRef = &((*lastPtrRef)->next);// tricky: advance to point to// the next ".next" field}return(result);}SortedMerge() Using RecursionMerge() is one of those nice recursive problems where the recursive solution code ismuch cleaner than the iterative code. You probably wouldn't want to use the recursiveversion for production code however, because it will use stack space which isproportional to the length of the lists.struct node* SortedMerge3(struct node* a, struct node* b) {struct node* result = NULL;
31// Base casesif (a==NULL) return(b);else if (b==NULL) return(a);// Pick either a or b, and recurif (a->data <= b->data) {result = a;result->next = SortedMerge3(a->next, b);}else {result = b;result->next = SortedMerge3(a, b->next);}return(result);}15 — MergeSort() SolutionThe MergeSort strategy is: split into sublists, sort the sublists recursively, merge the twosorted lists together to form the answer.void MergeSort(struct node** headRef) {struct node* head = *headRef;struct node* a;struct node* b;// Base case -- length 0 or 1if ((head == NULL) || (head->next == NULL)) {return;}FrontBackSplit(head, &a, &b);// Split head into 'a' and 'b' sublists// We could just as well use AlternatingSplit()MergeSort(&a);// Recursively sort the sublistsMergeSort(&b);*headRef  = SortedMerge(a, b);// answer = merge the two sorted lists together}(Extra for experts) Using recursive stack space proportional to the length of a list is notrecommended. However, the recursion in this case is ok — it uses stack space which isproportional to the log of the length of the list. For a 1000 node list, the recursion willonly go about 10 deep. For a 2000 node list, it will go 11 deep. If you think about it, youcan see that doubling the size of the list only increases the depth by 1.16 — SortedIntersect() SolutionThe strategy is to advance up both lists and build the result list as we go. When thecurrent point in both lists are the same, add a node to the result. Otherwise, advancewhichever list is smaller. By exploiting the fact that both lists are sorted, we only traverseeach list once. To build up the result list, both the dummy node and local referencestrategy solutions are shown...// This solution uses the temporary dummy to build up the result liststruct node* SortedIntersect(struct node* a, struct node* b) {struct node dummy;
32struct node* tail = &dummy;dummy.next = NULL;// Once one or the other list runs out -- we're donewhile (a!=NULL && b!=NULL) {if (a->data == b->data) {Push((&tail->next), a->data);tail = tail->next;a = a->next;b = b->next;}else if (a->data < b->data) {// advance the smaller lista = a->next;}else {b = b->next;}}return(dummy.next);}// This solution uses the local referencestruct node* SortedIntersect2(struct node* a, struct node* b) {struct node* result = NULL;struct node** lastPtrRef = &result;// Advance comparing the first nodes in both lists.// When one or the other list runs out, we're done.while (a!=NULL && b!=NULL) {if (a->data == b->data) {// found a node for the intersectionPush(lastPtrRef, a->data);lastPtrRef = &((*lastPtrRef)->next);a=a->next;b=b->next;}else if (a->data < b->data) {// advance the smaller lista=a->next;}else {b=b->next;}}return(result);}17 — Reverse() SolutionThis first solution uses the "Push" strategy with the pointer re-arrangement hand codedinside the loop. There's a slight trickyness in that it needs to save the value of the"current->next" pointer at the top of the loop since the body of the loop overwrites thatpointer./* Iterative list reverse. Iterate through the list left-right.
33 Move/insert each node to the front of the result list -- like a Push of the node.*/static void Reverse(struct node** headRef) {struct node* result = NULL;struct node* current = *headRef;struct node* next;while (current != NULL) {next = current->next;// tricky: note the next nodecurrent->next = result;// move the node onto the resultresult = current;current = next;}*headRef = result;}Here's the variation on the above that uses MoveNode() to do the work...static void Reverse2(struct node** headRef) {struct node* result = NULL;struct node* current = *headRef;while (current != NULL) {MoveNode(&result, &current);}*headRef = result;}Finally, here's the back-middle-front strategy...// Reverses the given linked list by changing its .next pointers and// its head pointer. Takes a pointer (reference) to the head pointer.void Reverse(struct node** headRef) {if (*headRef != NULL) {// special case: skip the empty list/* Plan for this loop: move three pointers: front, middle, back down the list in order. Middle is the main pointer running down the list. Front leads it and Back trails it. For each step, reverse the middle pointer and then advance all three to get the next node.*/struct node* middle = *headRef;// the main pointerstruct node* front = middle->next;// the two other pointers (NULL ok)struct node* back = NULL;while (1) {middle->next = back;// fix the middle nodeif (front == NULL) break;// test if done
34back = middle;// advance the three pointersmiddle = front;front = front->next;}*headRef = middle;// fix the head pointer to point to the new front}}18 —  RecursiveReverse() SolutionProbably the hardest part is accepting the concept that theRecursiveReverse(&rest) does in fact reverse the rest. Then then there's a trickto getting the one front node all the way to the end of the list. Make a drwaing to see howthe trick works.void RecursiveReverse(struct node** headRef) {struct node* first;struct node* rest;if (*headRef == NULL) return;// empty list base casefirst = *headRef;// suppose first = {1, 2, 3}rest = first->next;//         rest = {2, 3}if (rest == NULL) return;// empty rest base caseRecursiveReverse(&rest);// Recursively reverse the smaller {2, 3} case// after: rest = {3, 2}first->next->next = first;// put the first elem on the end of the listfirst->next = NULL;// (tricky step -- make a drawing)*headRef = rest;// fix the head pointer}The inefficient soluition is to reverse the last n-1 elements of the list, and then iterate allthe way down to the new tail and put the old head node there. That solution is very slowcompared to the above which gets the head node in the right place without extra iteration.
35AppendixBasic Utility Function ImplementationsHere is the source code for the basic utility functions.Length()// Return the number of nodes in a listint Length(struct node* head) {int count = 0;struct node* current = head;while (current != NULL) {count++;current=current->next;}return(count);}Push()// Given a reference (pointer to pointer) to the head// of a list and an int, push a new node on the front of the list.// Creates a new node with the int, links the list off the .next of the// new node, and finally changes the head to point to the new node.void Push(struct node** headRef, int newData) {struct node* newNode =(struct node*) malloc(sizeof(struct node));// allocate nodenewNode->data = newData;// put in the datanewNode->next = (*headRef);// link the old list off the new node(*headRef) = newNode;// move the head to point to the new node}BuildOneTwoThree()// Build and return the list {1, 2, 3}struct node* BuildOneTwoThree() {struct node* head = NULL;// Start with the empty listPush(&head, 3);// Use Push() to add all the dataPush(&head, 2);Push(&head, 1);return(head);}
